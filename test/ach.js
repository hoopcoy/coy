/* global describe,it */
'use strict'
import { Ach } from '../lib/ach'
import should from 'should'

describe('Ach (Aes+Cbc+Hmac)', function () {
  this.timeout(4000)

  it('should exist', function () {
    should.exist(Ach)
  })

  describe('@encrypt', function () {
    it('should encrypt data', function () {
      const data = Buffer.from([0])
      const cipherKey = Buffer.alloc(256 / 8)
      cipherKey.fill(0x12)
      const encBuf = Ach.encrypt(data, cipherKey)
      encBuf.length.should.equal(256 / 8 + 256 / 8)
    })

    it('should encrypt this data and get a known value generated with sjcl', function () {
      const data = Buffer.from('this is my test data')
      const cipherKey = Buffer.alloc(256 / 8)
      cipherKey.fill(0x70)
      const ivBuf = Buffer.alloc(128 / 8)
      ivBuf.fill(0x07)
      const encBuf = Ach.encrypt(data, cipherKey, ivBuf)
      const enchex =
        '5ca7fb171ef5001fdc26aca9ca806279200a8dd9bc3580b95d80335ed358627e07070707070707070707070707070707a1e5dd6b76089f0c055d718c9f597d22d727422cb1a28dd1a30aacb0cb008c1d'
      encBuf.toString('hex').should.equal(enchex)
    })
  })

  describe('@asyncEncrypt', function () {
    it('should encrypt data', async function () {
      const data = Buffer.from([0])
      const cipherKey = Buffer.alloc(256 / 8)
      cipherKey.fill(0x12)
      const encBuf = await Ach.asyncEncrypt(data, cipherKey)
      encBuf.length.should.equal(256 / 8 + 256 / 8)
    })

    it('should encrypt this data and get a known value generated with sjcl', async function () {
      const data = Buffer.from('this is my test data')
      const cipherKey = Buffer.alloc(256 / 8)
      cipherKey.fill(0x70)
      const ivBuf = Buffer.alloc(128 / 8)
      ivBuf.fill(0x07)
      const encBuf = await Ach.asyncEncrypt(data, cipherKey, ivBuf)
      const enchex =
        '5ca7fb171ef5001fdc26aca9ca806279200a8dd9bc3580b95d80335ed358627e07070707070707070707070707070707a1e5dd6b76089f0c055d718c9f597d22d727422cb1a28dd1a30aacb0cb008c1d'
      encBuf.toString('hex').should.equal(enchex)
    })
  })

  describe('@decrypt', function () {
    it('should throw an error of data is incorrect length', function () {
      const encBuf = Buffer.from(
        '7519aff134f4fd273b41e50e6b9fac4d39b42afe6c2335551a4c06c4bdf9198d667b0dd26e935fdd5454e99ab27d8c17404199c79cb0c9d3884d2bd5bbd2b6',
        'hex'
      )
      const cipherKey = Buffer.alloc(256 / 8)
      cipherKey.fill(0x12)
      ;(function () {
        Ach.decrypt(encBuf, cipherKey)
      }.should.throw(
        'The encrypted data must be at least 256+128+128 bits, which is the length of the Hmac plus the iv plus the smallest encrypted data size'
      ))
    })

    it('should throw an error of data for incorrect hmac', function () {
      const encBuf = Buffer.from(
        '0019aff134f4fd273b41e50e6b9fac4d39b42afe6c2335551a4c06c4bdf9198d667b0dd26e935fdd5454e99ab27d8c17404199c79cb0c9d3884d2bd5bbd2b619',
        'hex'
      )
      const cipherKey = Buffer.alloc(256 / 8)
      cipherKey.fill(0x12)
      ;(function () {
        Ach.decrypt(encBuf, cipherKey)
      }.should.throw(
        'Message authentication failed - Hmacs are not equivalent'
      ))
    })

    it('should decrypt data', function () {
      const encBuf = Buffer.from(
        '7519aff134f4fd273b41e50e6b9fac4d39b42afe6c2335551a4c06c4bdf9198d667b0dd26e935fdd5454e99ab27d8c17404199c79cb0c9d3884d2bd5bbd2b619',
        'hex'
      )
      const cipherKey = Buffer.alloc(256 / 8)
      cipherKey.fill(0x12)
      const data = Ach.decrypt(encBuf, cipherKey)
      data.toString('hex').should.equal('00')
    })

    it('should decrypt this encrypted data generated by sjcl', function () {
      const ptbuf = Buffer.from('this is my test data')
      const pthex = ptbuf.toString('hex')
      const encBuf = Buffer.from(
        '5ca7fb171ef5001fdc26aca9ca806279200a8dd9bc3580b95d80335ed358627e07070707070707070707070707070707a1e5dd6b76089f0c055d718c9f597d22d727422cb1a28dd1a30aacb0cb008c1d',
        'hex'
      )
      const cipherKey = Buffer.alloc(256 / 8)
      cipherKey.fill(0x70)
      const data = Ach.decrypt(encBuf, cipherKey)
      data.toString('hex').should.equal(pthex)
    })
  })

  describe('@asyncDecrypt', function () {
    it('should throw an error of data is incorrect length', async function () {
      const encBuf = Buffer.from(
        '7519aff134f4fd273b41e50e6b9fac4d39b42afe6c2335551a4c06c4bdf9198d667b0dd26e935fdd5454e99ab27d8c17404199c79cb0c9d3884d2bd5bbd2b6',
        'hex'
      )
      const cipherKey = Buffer.alloc(256 / 8)
      cipherKey.fill(0x12)
      let error
      try {
        await Ach.asyncDecrypt(encBuf, cipherKey)
      } catch (err) {
        error = err
      }
      error.message.should.equal(
        'The encrypted data must be at least 256+128+128 bits, which is the length of the Hmac plus the iv plus the smallest encrypted data size'
      )
    })

    it('should throw an error of data for incorrect hmac', async function () {
      const encBuf = Buffer.from(
        '0019aff134f4fd273b41e50e6b9fac4d39b42afe6c2335551a4c06c4bdf9198d667b0dd26e935fdd5454e99ab27d8c17404199c79cb0c9d3884d2bd5bbd2b619',
        'hex'
      )
      const cipherKey = Buffer.alloc(256 / 8)
      cipherKey.fill(0x12)
      let error
      try {
        await Ach.asyncDecrypt(encBuf, cipherKey)
      } catch (err) {
        error = err
      }
      error.message.should.equal(
        'Message authentication failed - Hmacs are not equivalent'
      )
    })

    it('should decrypt data', async function () {
      const encBuf = Buffer.from(
        '7519aff134f4fd273b41e50e6b9fac4d39b42afe6c2335551a4c06c4bdf9198d667b0dd26e935fdd5454e99ab27d8c17404199c79cb0c9d3884d2bd5bbd2b619',
        'hex'
      )
      const cipherKey = Buffer.alloc(256 / 8)
      cipherKey.fill(0x12)
      const data = await Ach.asyncDecrypt(encBuf, cipherKey)
      data.toString('hex').should.equal('00')
    })

    it('should decrypt this encrypted data generated by sjcl', async function () {
      const ptbuf = Buffer.from('this is my test data')
      const pthex = ptbuf.toString('hex')
      const encBuf = Buffer.from(
        '5ca7fb171ef5001fdc26aca9ca806279200a8dd9bc3580b95d80335ed358627e07070707070707070707070707070707a1e5dd6b76089f0c055d718c9f597d22d727422cb1a28dd1a30aacb0cb008c1d',
        'hex'
      )
      const cipherKey = Buffer.alloc(256 / 8)
      cipherKey.fill(0x70)
      const data = await Ach.asyncDecrypt(encBuf, cipherKey)
      data.toString('hex').should.equal(pthex)
    })
  })
})
